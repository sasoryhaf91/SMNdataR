#' Extract Station Coordinates Robustly (internal)
#'
#' Retrieves the metadata lines for a given station using the URL generated by
#' `smn_int_get_url()`, searches for lines containing latitude/longitude/altitude
#' labels (case-insensitive, ES/EN variants), and extracts the first numeric
#' value from each line. If a coordinate cannot be extracted or fails range
#' validation, `NA` is returned for that coordinate.
#'
#' @param station Station code (character or numeric).
#' @param max_attempts Integer. Maximum retries for the metadata download (default `10`).
#' @param encoding Character. Encoding for `readLines()` (default `"UTF-8"`).
#' @param add_meta_cols Logical. If `TRUE`, include `station` and `source_url`
#'   as explicit columns in the returned data (default `FALSE`). These are
#'   always attached as attributes for provenance.
#'
#' @return A one-row `data.frame` with columns `latitude`, `longitude`, `altitude`.
#'   Attributes `station` and `source_url` are attached.
#'
#' @keywords internal
#' @examples NULL
smn_int_extract_coordinates <- function(station,
                                        max_attempts  = 10,
                                        encoding      = "UTF-8",
                                        add_meta_cols = FALSE) {
  # Helper: build NA-row output consistently
  .na_out <- function(st, url, add_cols = FALSE) {
    out <- data.frame(
      latitude  = NA_real_,
      longitude = NA_real_,
      altitude  = NA_real_
    )
    attr(out, "station")    <- st
    attr(out, "source_url") <- url
    if (isTRUE(add_cols)) {
      out$station    <- st
      out$source_url <- url
      out <- out[, c("latitude","longitude","altitude","station","source_url"), drop = FALSE]
    }
    rownames(out) <- NULL
    out
  }

  # ---- validate input --------------------------------------------------------
  if (missing(station) || !nzchar(as.character(station))) {
    stop("`station` must be a non-empty station code.")
  }
  station <- as.character(station)

  # ---- build URL (tolerant) --------------------------------------------------
  url <- tryCatch(
    smn_int_get_url(station),
    error = function(e) {
      warning("Invalid station id '", station, "': ", conditionMessage(e))
      return(NA_character_)
    }
  )
  if (is.na(url) || !nzchar(url)) {
    return(.na_out(station, url = NA_character_, add_cols = add_meta_cols))
  }

  # ---- fetch lines with retries ----------------------------------------------
  lines <- tryCatch(
    smn_int_handle_error(
      {
        readLines(url, warn = FALSE, encoding = encoding)
      },
      max_attempts = max_attempts,
      quiet        = TRUE,
      envir        = environment()
    ),
    error = function(e) {
      warning("Could not read metadata for station ", station, ": ", conditionMessage(e))
      NULL
    }
  )

  if (is.null(lines) || length(lines) == 0L) {
    warning("Insufficient metadata for station ", station)
    return(.na_out(station, url, add_cols = add_meta_cols))
  }

  lines <- trimws(lines)

  # ---- locate lines (ES/EN & abbreviations) ----------------------------------
  lat_idx <- grep("\\b(latitud|latitude|lat\\.?)(\\b|:)",  lines, ignore.case = TRUE, perl = TRUE)
  lon_idx <- grep("\\b(longitud|longitude|lon\\.?)(\\b|:)", lines, ignore.case = TRUE, perl = TRUE)
  alt_idx <- grep("\\b(altitud|altitude|alt\\.?)(\\b|:)",  lines, ignore.case = TRUE, perl = TRUE)

  if (!length(lat_idx)) lat_idx <- grep("\\blat", lines, ignore.case = TRUE)
  if (!length(lon_idx)) lon_idx <- grep("\\blon", lines, ignore.case = TRUE)
  if (!length(alt_idx)) alt_idx <- grep("\\balt", lines, ignore.case = TRUE)

  lat_line <- if (length(lat_idx)) lines[lat_idx[1L]] else NA_character_
  lon_line <- if (length(lon_idx)) lines[lon_idx[1L]] else NA_character_
  alt_line <- if (length(alt_idx)) lines[alt_idx[1L]] else NA_character_

  if (is.na(lat_line) || is.na(lon_line) || is.na(alt_line)) {
    warning("Metadata for station ", station, " does not contain complete coordinate information.")
    return(.na_out(station, url, add_cols = add_meta_cols))
  }

  # ---- numeric extraction -----------------------------------------------------
  latitude  <- smn_int_extract_numeric(lat_line)
  longitude <- smn_int_extract_numeric(lon_line)
  altitude  <- smn_int_extract_numeric(alt_line)

  # ---- hemisphere hints (force sign if line indicates S/W) -------------------
  if (!is.na(latitude)) {
    if (grepl("\\b(sur|south|\\bS\\b)", lat_line, ignore.case = TRUE) && latitude > 0) {
      latitude <- -abs(latitude)
    }
  }
  if (!is.na(longitude)) {
    if (grepl("\\b(oeste|west|\\bW\\b|poniente)", lon_line, ignore.case = TRUE) && longitude > 0) {
      longitude <- -abs(longitude)
    }
    if (grepl("\\b(este|east|\\bE\\b|oriente)", lon_line, ignore.case = TRUE) && longitude < 0) {
      longitude <- abs(longitude)
    }
  }

  # ---- range validation -------------------------------------------------------
  rng_warn <- FALSE
  if (!is.na(latitude)  && (latitude  < -90  || latitude  > 90))  { latitude  <- NA_real_; rng_warn <- TRUE }
  if (!is.na(longitude) && (longitude < -180 || longitude > 180)) { longitude <- NA_real_; rng_warn <- TRUE }
  if (rng_warn) warning("Out-of-range coordinate(s) for station ", station, " set to NA.")

  # ---- build output -----------------------------------------------------------
  out <- data.frame(latitude = latitude, longitude = longitude, altitude = altitude)
  attr(out, "station")    <- station
  attr(out, "source_url") <- url
  if (isTRUE(add_meta_cols)) {
    out$station    <- station
    out$source_url <- url
    out <- out[, c("latitude","longitude","altitude","station","source_url"), drop = FALSE]
  }
  rownames(out) <- NULL
  out
}

