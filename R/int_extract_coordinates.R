#' Extract Station Coordinates Robustly (internal)
#'
#' Retrieves the metadata lines for a given station using the URL generated by
#' `smn_int_get_url()`, searches for lines containing latitude/longitude/altitude
#' labels (case-insensitive, ES/EN variants), and extracts the first numeric
#' value from each line. If a coordinate cannot be extracted or fails range
#' validation, `NA` is returned for that coordinate.
#'
#' @param station Station code (character or numeric).
#' @param max_attempts Integer. Maximum retries for the metadata download (default `10`).
#' @param encoding Character. Encoding for `readLines()` (default `"UTF-8"`).
#' @param add_meta_cols Logical. If `TRUE`, include `station` and `source_url`
#'   as explicit columns in the returned data (default `FALSE`). These are
#'   always attached as attributes.
#'
#' @return A `data.frame` (one row) with columns:
#'   `latitude`, `longitude`, `altitude`. Attributes `station` and `source_url`
#'   are attached for provenance.
#'
#' @keywords internal
#' @noRd
smn_int_extract_coordinates <- function(station,
                                        max_attempts  = 10,
                                        encoding      = "UTF-8",
                                        add_meta_cols = FALSE) {
  # ---- validate input --------------------------------------------------------
  if (missing(station) || !nzchar(as.character(station))) {
    stop("`station` must be a non-empty station code.")
  }
  station <- as.character(station)

  # ---- build URL and fetch lines --------------------------------------------
  url <- smn_int_get_url(station)

  lines <- smn_int_handle_error({
    readLines(url, warn = FALSE, encoding = encoding)
  }, max_attempts = max_attempts, quiet = TRUE, envir = environment())

  if (is.null(lines) || length(lines) == 0L) {
    warning("Insufficient metadata for station ", station)
    out <- data.frame(latitude = NA_real_, longitude = NA_real_, altitude = NA_real_)
    attr(out, "station") <- station; attr(out, "source_url") <- url
    if (isTRUE(add_meta_cols)) out$station <- station; if (isTRUE(add_meta_cols)) out$source_url <- url
    return(out[, unique(c("latitude","longitude","altitude",
                          if (add_meta_cols) c("station","source_url"))), drop = FALSE])
  }

  # Pre-trim to avoid noise
  lines <- trimws(lines)

  # ---- locate lines (ES/EN & abbreviations) ---------------------------------
  # lat: Latitud|Latitude|Lat.
  # lon: Longitud|Longitude|Lon.
  # alt: Altitud|Altitude|Alt.
  lat_idx <- grep("\\b(latitud|latitude|lat\\.?)(\\b|:)",  lines, ignore.case = TRUE, perl = TRUE)
  lon_idx <- grep("\\b(longitud|longitude|lon\\.?)(\\b|:)", lines, ignore.case = TRUE, perl = TRUE)
  alt_idx <- grep("\\b(altitud|altitude|alt\\.?)(\\b|:)",  lines, ignore.case = TRUE, perl = TRUE)

  # Safeguard: if first search fails, try a looser one (rare layouts)
  if (!length(lat_idx)) lat_idx <- grep("\\blat", lines, ignore.case = TRUE)
  if (!length(lon_idx)) lon_idx <- grep("\\blon", lines, ignore.case = TRUE)
  if (!length(alt_idx)) alt_idx <- grep("\\balt", lines, ignore.case = TRUE)

  lat_line <- if (length(lat_idx)) lines[lat_idx[1L]] else NA_character_
  lon_line <- if (length(lon_idx)) lines[lon_idx[1L]] else NA_character_
  alt_line <- if (length(alt_idx)) lines[alt_idx[1L]] else NA_character_

  # ---- numeric extraction ----------------------------------------------------
  latitude  <- if (!is.na(lat_line)) smn_int_extract_numeric(lat_line)  else NA_real_
  longitude <- if (!is.na(lon_line)) smn_int_extract_numeric(lon_line) else NA_real_
  altitude  <- if (!is.na(alt_line)) smn_int_extract_numeric(alt_line)  else NA_real_

  # ---- hemisphere hints (force sign if line indicates S/W) -------------------
  # south / oeste → negative; north / east → non-negative (only if sign absent)
  if (!is.na(latitude)) {
    if (grepl("\\b(sur|south|\\bS\\b)", lat_line, ignore.case = TRUE) && latitude > 0) {
      latitude <- -abs(latitude)
    }
  }
  if (!is.na(longitude)) {
    if (grepl("\\b(oeste|west|\\bW\\b|poniente)", lon_line, ignore.case = TRUE) && longitude > 0) {
      longitude <- -abs(longitude)
    }
    if (grepl("\\b(este|east|\\bE\\b|oriente)", lon_line, ignore.case = TRUE) && longitude < 0) {
      longitude <- abs(longitude)
    }
  }

  # ---- range validation ------------------------------------------------------
  rng_warn <- FALSE
  if (!is.na(latitude)  && (latitude  < -90  || latitude  > 90))  { latitude  <- NA_real_; rng_warn <- TRUE }
  if (!is.na(longitude) && (longitude < -180 || longitude > 180)) { longitude <- NA_real_; rng_warn <- TRUE }
  if (rng_warn) warning("Out-of-range coordinate(s) for station ", station, " set to NA.")

  # ---- build output ----------------------------------------------------------
  out <- data.frame(
    latitude  = latitude,
    longitude = longitude,
    altitude  = altitude
  )
  attr(out, "station")    <- station
  attr(out, "source_url") <- url

  if (isTRUE(add_meta_cols)) {
    out$station    <- station
    out$source_url <- url
    # keep standard columns first
    out <- out[, c("latitude","longitude","altitude","station","source_url"), drop = FALSE]
  }

  rownames(out) <- NULL
  out
}
